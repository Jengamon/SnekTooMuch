; STANDARD CONVENTIONS
; name! means that this method can modify non-local environments (e.g. set!, del!)
; name? means that this method querys if a value satisfies some given condition (e.g. num?, list?)
; ~name means that this method generates code that can be executed (basically a macro)

(define (null l)
    (=? nil l)
)

(define (rev l) 
    (if (null l)
        nil 
        (concat (rev (cdr l)) (list (car l)))
    )
)
(define (range start stop step)
    (letrec
       (
           (
               range-iter (lambda (l i stop step)
                   (if (>= i stop)
                       l
                       (range-iter (concat l (list i)) (+ i step) stop step)
                   )
               )
            )
        )
        (range-iter (list) start stop step)
    )
    ; (if (>= start stop)
    ;    nil
    ;    (concat (list start) (range (+ start step) stop step))
    ; )
)
(define (poly-val coeffs x)
    (if (=? coeffs nil)
        0
        (+ (car coeffs) (* x (poly-val (cdr coeffs) x)))
    )
)
(define (factorial n) ; non tail-recursive
    (if (<= n 1) 
        1 
        (* n (factorial (- n 1)))
    )
)
(define (factorial-trec x) ; tail-recursive
    (define (fact-tail x accum)
        (if (=? x 0) 
            accum
            (fact-tail (- x 1) (* x accum))
        )
    )
    (fact-tail x 1)
)
(define (set-elt-at-index l i v)
    (if (=? i 0)
        (set-car l v)
        (set-elt-at-index (cdr l) (- i 1) v)
    )
)
(define (play x)
    (letrec
        (
            (
                ping 
                (lambda (n) 
                    (concat '(ping) 
                        (if (> n 0) 
                            (pong (- n 1)) 
                            nil
                        )
                    )
                )
            )
            (
                pong
                (lambda (n) 
                    (concat '(pong)
                        (if (> n 0) 
                            (ping (- n 1)) 
                            nil
                        )
                    )
                )
            )
        )

        (ping x)
    )
)

(define (playi n)
    (letrec 
        (
            (
                play-iter
                (lambda (l n i)
                    (if (>= n 0) 
                        (if (=? i 'ping)
                            (play-iter (concat l (list i)) (- n 1) 'pong)
                            (play-iter (concat l (list i)) (- n 1) 'ping)
                        )
                        l
                    )
                )
            )
        )

        (play-iter nil n 'ping)
    )
)

(define (take l n)
    (if (null l)
        nil
        (if (> n 0)
            (concat (list (car l)) (take (cdr l) (- n 1)))
            nil
        )
    )
)

(define (skip l n)
    (if (null l)
        nil
        (if (> n 0)
            (skip (cdr l) (- n 1))
            l
        )
    )
)

(define (repeat i n)
    (letrec
        (
            (
                repeat-iter
                (lambda (l i n) 
                    (if (> n 0)
                        (repeat-iter (concat l (list i)) i (- n 1))
                        l
                    )
                )
            )
        )
        (repeat-iter nil i n)
    )
)

(define (find? l v) ; Can v be found in list l
    (if (=? l nil)
        #f
        (if (=? (car l) v)
            #t
            (find? (cdr l) v)
        )
    )
)

(define (abs n)
    (if (>= n 0)
        n
        (- 0 n)
    )
)

(define (frac n) 
    (- n (int n))
)

(define (floor n) 
    (- n (frac n))
)

(define (ceil n) 
    (+ n (- 1 (frac n)))
)

(define (round n)
    (if (>= n 0)
        (if (>= (frac n) 0.5)
            (ceil n)
            (floor n)
        )
        (if (>= (frac n) -0.5)
            (floor n)
            (ceil n)
        )
    )
)

(define (~forth stack asaf code) ; the starting stack, additional single-argument-functions, code to execute
    (define saf (concat '(abs frac floor ceil round) asaf)) ; A list of methods that we will only call with one argument
    (if (null code)
        `(list ,@(rev stack))
        (let
            (
                (item (car code))
            )
            (if (num? item)
                (~forth (concat (list item) stack) asaf (cdr code))
                ; Assume this is an operator, and that it takes exactly two arguments, unless this name is in saf
                (if (find? saf item)
                    (~forth (concat (list `(,item ,@(take stack 1))) (skip stack 1)) asaf (cdr code))
                    (~forth (concat (list `(,item ,(rev (take stack 2)))) (skip stack 2)) asaf (cdr code))
                )
            )
        )
    )
)

(define (forth stack asaf code) ; Now this is just a macro call
    ,(~forth stack asaf code)
)

(define (tree s) ; s should be a list of tokens that we can process into a tree using (left . right) syntax
    (if (and (list? s) (=? (length s) 3) (=? (elt-at-index s 1) '.))
        (cons (tree (elt-at-index s 0)) (tree (elt-at-index s 2)))
        s
    )
)

(define (~list-to-tree l)
    (define (tree-list l) 
        (if (=? nil l) 
            nil 
            `(,(car l) . ,(tree-list (cdr l)))
        )
    ) 
    `(tree ',(tree-list l))
)