(define (null l)
    (=? nil l)
)
(define (rev l) 
    (if (null l)
        nil 
        (concat (rev (cdr l)) (list (car l)))
    )
)
(define (range start stop step)
    (letrec
       (
           (
               range-iter (lambda (l i stop step)
                   (if (>= i stop)
                       l
                       (range-iter (concat l (list i)) (+ i step) stop step)
                   )
               )
            )
        )
        (range-iter (list) start stop step)
    )
    ;(if (>= start stop)
    ;    nil
    ;    (concat (list start) (range (+ start step) stop step))
    ;)
)
(define (poly-val coeffs x)
    (if (=? coeffs nil)
        0
        (+ (car coeffs) (* x (poly-val (cdr coeffs) x)))
    )
)
(define (factorial n) ; non tail-recursive
    (if (<= n 1) 
        1 
        (* n (factorial (- n 1)))
    )
)
(define (factorial-trec x) ; tail-recursive
    (define (fact-tail x accum)
        (if (=? x 0) 
            accum
            (fact-tail (- x 1) (* x accum))
        )
    )
    (fact-tail x 1)
)
(define (set-elt-at-index l i v)
    (if (=? i 0)
        (set-car! l v)
        (set-elt-at-index (cdr l) (- i 1) v)
    )
)
(define (play x)
    (letrec
        (
            (
                ping 
                (lambda (n) 
                    (concat '(ping) 
                        (if (> n 0) 
                            (pong (- n 1)) 
                            nil
                        )
                    )
                )
            )
            (
                pong
                (lambda (n) 
                    (concat '(pong)
                        (if (> n 0) 
                            (ping (- n 1)) 
                            nil
                        )
                    )
                )
            )
        )

        (ping x)
    )
)

(define (playi n)
    (letrec 
        (
            (
                play-iter
                (lambda (l n i)
                    (if (>= n 0) 
                        (if (=? i 'ping)
                            (play-iter (concat l (list i)) (- n 1) 'pong)
                            (play-iter (concat l (list i)) (- n 1) 'ping)
                        )
                        l
                    )
                )
            )
        )

        (play-iter nil n 'ping)
    )
)

(define (take l n)
    (if (null l)
        nil
        (if (> n 0)
            (concat (list (car l)) (take (cdr l) (- n 1)))
            nil
        )
    )
)

(define (skip l n)
    (if (null l)
        nil
        (if (> n 0)
            (skip (cdr l) (- n 1))
            l
        )
    )
)

(define (repeat i n)
    (letrec
        (
            (
                repeat-iter
                (lambda (l i n) 
                    (if (> n 0)
                        (repeat-iter (concat l (list i)) i (- n 1))
                        l
                    )
                )
            )
        )
        (repeat-iter nil i n)
    )
)

(define (forth stack code)
    (if (null code)
        stack
        (let
            (
                (item (car code))
            )
            (if (num? item)
                (forth (concat (list item) stack) (cdr code))
                ; Assume this is an operator, and that it takes exactly two arguments
                (forth (concat (skip stack 2) (list ,`(,item ,@(take stack 2)))) (cdr code))
            )
        )
    )
)

(define (abs n)
    (if (>= n 0)
        n
        (- 0 n)
    )
)

(define (frac n) 
    (- n (int n))
)

(define (floor n) 
    (- n (frac n))
)

(define (ceil n) 
    (+ n (- 1 (frac n)))
)

(define (round n)
    (if (>= n 0)
        (if (>= (frac n) 0.5)
            (ceil n)
            (floor n)
        )
        (if (>= (frac n) -0.5)
            (floor n)
            (ceil n)
        )
    )
)